# 作用域

## 作用域链

```
作用域链本质上是底层的变量查找机制
1.在函数被执行时，会优先查找当前函数作用域中查找变量
2.如果当前作用域查找不到则会依次逐级查找父级作用域，直到全局作用域
```

## 垃圾作用回收机制

```js
生命周期
1.内存分配
2.内存使用
3.内存回收
说明:
	全局变量一般不会回收
    一般情况下局部变量的值，不用了，会被自动回收掉
    
内存泄漏:程序中分配的内存由于某种原因程序未释放，或无法释放叫做内存泄漏
通过null来释放

//垃圾回收机制
1.引用计数
缺点:嵌套引用
如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收导致内存泄漏,例如:
function fn(){
    let o1={}
    let o2={}
    o1.a=o2
    o2.a=o1
    return '计数器无法回收'
}
因为他们技术无法永远为0
2.标记清除法
标记清除法将"不再使用的对象"定义为'无法达到的对象'
就是从根部(js中就是全局变量),出发定时扫描内存中的对象，凡是能从根部到达的都是需要使用的
那些无法到达的对象会被标记不再使用稍后进行回收
```

## 闭包

```js
闭包=内层函数+外层函数的变量
会有内存泄漏
例如:
        // 外部可以访问使用函数内部的变量
        function funout() {
            let a = 10
            function fn() {
                console.log(a)
            }
            return fn
        }
        // funout() === fn === function fn() { }
        let tim = funout()
        tim()
```

## 变量提升

```js
//当代码执行之前会把所有var定义的变量提到最前面
//只提升声明，不提升赋值
```

# 函数进阶

```
函数用var fun=function(){
	...
}定义时声明必须在使用前面，var声明时，会提前，会出现只声明名字，没有内容，所以会报错
```

## 动态参数

```js
//在参数不确定有几个的时候进行动态参数的使用
arguments是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参
```

## 剩余参数

```js
//剩余参数允许我们将一个不定数量的参数表示为一个数组
function getSum(a,b,...arr){
    //arr为数组
    //有第一个参数给a
    //有第二个参数给b 
    //剩余的参数给arr数组
}

///展开运算符
写在函数外面的...是展开运算符
用于求最大值的方法Math.max(...arr)
合并数组arr=[...arr1,...arr2]
```

## 箭头函数

```js
箭头函数更适合用于那些本来需要匿名函数的地方
const fn=()=>{
	...
}
当参数只有一个的时候可以不要括号
const fn=x=>{
    ...
}
当只有一个参数和一行代码时可以简写
const fn=x=>x*x	//不用return也可以返回

可以直接返回一个对象
const fn=uname=>({uanme:uname})//要加一个小括号

箭头函数不会创建自己的"this"，它只会从自己的作用域链的上一层沿用this
```

# 解构赋值

## 数组解构

```js
数组解构是将"数组的单元值"快速"批量"赋值给"一系列变量"的简洁语法
例如
const arr = [100, 200, 300]
const [a, b, c] = arr
console.log(a)
console.log(b)
console.log(c) 
//交换两个变量
let a = 1
let b = 2;	//注意一定要加个分号，在数组解构的时候一定要加个分号，使用数组的时候也得用分号
[a, b] = [b, a]
console.log(a, b)

//当单元值多变量少时，多的变量为undefined
防止undefined出现
const [a=0,b=0]=[]
const [a,b, ,d]=[1,2,3,4]//a=1,b=2,d=4
const [a,b,[c,d]]=[1,2,[3,4]]

//当变量少单元值多时，可以用剩余参数的方法来执行...arr来接受
```

## 对象结构

```
对象解构是将对象属性和方法快速批量赋值给一系列变量的简洁语法
基本语法
1.赋值运算符 =左侧的{}用于批量声明变量，右侧对象的属性值将被赋值给左侧的变量
2.对象属性的值将被赋值给与属性名相同的变量
3.注意解构的变量名不要和外面的变量名冲突否则报错
4.对象中找不到与变量名一致的属性时变量值为 undefined
```

